package io.github.shayf0x.spigotwarden;

import org.gradle.internal.jvm.Jvm;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * It's useful class with many useful methods for SpigotWarden
 * <br><strong>Methods:</strong>
 * <br>-{@link #createIfNotExistBuildOutput()}
 * <br>-{@link #testBuildTools(String)}
 * <br>-{@link #testSpecialSource()}
 * <br>-{@link #install(URL, Path)}
 * <br>-{@link #newUrl(String)}
 * <br>-{@link #cmdBuildTools(String)}
 * <br>-{@link #runCommand(String[], Path)}
 * <br>-{@link #resolve(URL, String...)}
 */
public class Manager {
    private final SpigotWarden main;
    private String SPECIAL_SOURCE = "https://repo.maven.apache.org/maven2/net/md-5/SpecialSource";

    public Manager(SpigotWarden main) {
        this.main = main;
    }

    /**
     * If Output directory doesn't exist, this method create dir
     * @return [<i>boolean</i>] if dir has been created
     */
    public boolean createIfNotExistBuildOutput(){
        return main.getExtension().getBuildOutput().get().mkdirs();
    }

    /**
     * If SpecialSource.jar doesn't in plugin folder, this method install his at the latest version
     * @return [<i>String</i>] SpecialSource version installed
     */
    public String testSpecialSource(){
        final String latestVersion = getLatestVersion(SPECIAL_SOURCE);
        final String fileName = "SpecialSource-"+latestVersion+".jar";
        final Path root = Path.of(System.getProperty("user.dir")).resolve(".gradle").resolve("spigotwarden").resolve(fileName);
        if(!root.toFile().exists()){
            final URL url = resolve(resolve(newUrl(SPECIAL_SOURCE)), latestVersion, String.format("SpecialSource-%s-shaded.jar", latestVersion));
            install(url, root);
        }
        return latestVersion;
    }

    /**
     *That method test if all files generated by BuildTools and necessary for SpecialSource are present
     * @param version [<i>{@link String}</i>] (e.g: <i>1.19-R0.1-SNAPSHOT</i>).
     * @return [<i>boolean</i>] if all BuilderTools files are present
     * <br><strong>BuildTools files:</strong>
     * <br>-{@link PathBank#REMAPPED_MOJANG REMAPPED_MOJANG}
     * <br>-{@link PathBank#MAPS_MOJANG MAPS_MOJANG}
     * <br>-{@link PathBank#REMAPPED_OBF REMAPPED_OBF}
     * <br>-{@link PathBank#MAPS_SPIGOT MAPS_SPIGOT}
     */
    public boolean testBuildTools(String version) {
        boolean good = true;
        for (PathBank value : PathBank.values()) {
            final File file = new File(value.toPath(version).toUri());
            if(!file.exists())good = false;
        }
        return good;
    }

    /**
     * That method install file from internet to path
     * @param url [<i>{@link URL}</i>] - Internet Url of file want to download <i>e.g: "https://repo.maven.apache.org/maven2/net/md-5/SpecialSource/1.11.0/SpecialSource-1.11.0-shaded.jar"</i>
     * @param root [<i>{@link Path}</i>] - Path of install output
     */
    public void install(URL url, Path root) {
        try (final InputStream inputStream = url.openStream()) {
            final File file = new File(root.toString());
            file.mkdirs();
            Files.copy(inputStream, root, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * this method allows easily to generate URL with a String without worrying about the exception
     * @param str [<i>{@link String}</i>] - path
     * @return [<i>{@link URL}</i>] Url generated
     */
    public URL newUrl(String str){
        try {
            return new URL(str);
        } catch (MalformedURLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Be like Path#resolve()
     * @param url [<i>{@link URL}</i>] - base url
     * @param str [<i>{@link String}</i>] - path to add
     * @return [<i>{@link URL}</i>] Url generated
     */
    private URL resolve(URL url, String str){
        final String urlStr = url.toString();
        try {
            return new URL(String.format("%s/%s", urlStr, str));
        } catch (MalformedURLException e) {
            throw new RuntimeException(e);
        }
    }
    public URL resolve(URL url, String... str){
        URL finalUrl = url;
        for (String value:str) {
            finalUrl = resolve(finalUrl, value);
        }
        return finalUrl;
    }

    /**
     * this method run BuildTools command to generate all BuildTools' files
     * @param version [<i>{@link String}</i>] - version of spigot (e.g: <i>1.19-R0.1-SNAPSHOT</i>).
     */
    public void cmdBuildTools(String version){
        final Path root = Path.of(System.getProperty("user.dir")).resolve(".gradle").resolve("spigotwarden").resolve("BuildTools");
        final URL url = newUrl("https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar");
        final Path buildTools = root.resolve("BuildTools.jar");
        final String versionSpigot = version.split("-")[0];

        install(url, buildTools);

        String[] command = new String[] {
                Jvm.current().getJavaExecutable().getAbsolutePath(),
                "-jar",
                "BuildTools.jar",
                "--rev",
                versionSpigot,
                "--remapped"
        };

        runCommand(command, root);

    }

    /**
     * run Command like cmd.exe commands
     * @param content [<i>{@link String}[]</i>] content of command in the format of an array of Strings
     * @param root [<i>{@link Path}</i>] directory where command will be executed
     */
    public void runCommand(String[] content, Path root){
        try {
            ProcessBuilder pb = new ProcessBuilder(content);
            pb.directory(root.toFile());
            pb.redirectErrorStream(true);
            Process p = pb.start();
            logOutput(p.getInputStream(), "");
            p.waitFor();
            p.destroy();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    private void logOutput(InputStream inputStream, String prefix) {
        Scanner scanner = new Scanner(inputStream, "UTF-8");
        while (scanner.hasNextLine()) {
            System.out.println(prefix + scanner.nextLine());
        }
        scanner.close();
    }


    private String getLatestVersion(String urlStr) {
        try (final BufferedReader br = new BufferedReader(new InputStreamReader(new URL(urlStr).openStream()))) {
            List<String> list = new ArrayList();
            String msg = null;
            while ((msg = br.readLine()) != null)
                addIfVersion(msg, list);

            return getMaxValue(list);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
    private void addIfVersion(String msg, List<String> list) {
        final Pattern pattern = Pattern.compile(">\\d[\\d\\.]+\\d/<");
        final Matcher matcher = pattern.matcher(msg);
        if(matcher.find())
            list.add(matcher.group().replaceAll(">", "").replaceAll("/<", ""));
    }
    private String getMaxValue(List<String> numbers){
        final List<Integer> toInteger = numbers.stream().map(value -> Integer.parseInt(value.replaceAll("\\.", ""))).collect(Collectors.toList());
        return numbers.get(toInteger.indexOf(Collections.max(toInteger)));
    }
}
